// ecgarrhy_v1
// This file was @generated by ai8xize.py --verbose --log --test-dir /~/MAX78000/ --prefix ecgarrhy_v1 --checkpoint-file trained/ecgarrhy-v1-3Classes-qat8.pth.tar --config-file networks/ecgarrhy_v1.yaml --softmax --device MAX78000 --compact-data --mexpress --timer 0 --display-checkpoint --board-name FTHR_RevA --yamllint none --overwrite

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "mxc.h"
#include "cnn.h"
#include "sampledata.h"
#include "sampleoutput.h"
#include "mxc_device.h"
#include "mxc_sys.h"
#include "nvic_table.h"
#include "board.h"
#include "uart.h"
#include "gpio.h"
#include "mxc_delay.h"
#include "nvic_table.h"

volatile uint32_t cnn_time; // Stopwatch
#define UART_BAUD_RATE 9600
#define READING_UART 2
#define DATA_SIZE 1000
#define PULSE_FREQUENCY 125 // Hz
#define PULSE_PIN MXC_GPIO_PIN_6
#define PULSE_PORT MXC_GPIO0
#define UART_TX_PIN MXC_GPIO_PIN_1 //  UART TX pin p1.1
#define UART_RX_PIN MXC_GPIO_PIN_0//  UART RX pin p1.0
#define UART_PORT MXC_GPIO1
uint8_t received_data[DATA_SIZE];
volatile uint16_t data_index = 0;
mxc_uart_req_t read_req;
mxc_uart_req_t write_req; // For UART write operation
volatile int READ_FLAG;


// 1-channel 1000x1 data input (1000 bytes / 250 32-bit words):
// HWC 1000x1, channels 0 to 0
//static const uint32_t input_0[] = SAMPLE_INPUT_0;
static uint32_t input_0[DATA_SIZE];

void load_input(void)
{
  // This function loads the sample data input -- replace with actual data


  memcpy32((uint32_t *) 0x50400000, input_0, DATA_SIZE);
}

// Expected output of layer 6 for ecgarrhy_v1 given the sample input (known-answer test)
// Delete this function for production code

void UART2_IRQHandler(void) {
   MXC_UART_AsyncHandler(MXC_UART_GET_UART(READING_UART));
   data_index++;
   if (data_index >= DATA_SIZE) {
       NVIC_DisableIRQ(MXC_UART_GET_IRQ(READING_UART));
   }
}
void uart_setup(void) {
   mxc_uart_regs_t* uart = MXC_UART_GET_UART(READING_UART);
   MXC_UART_Init(MXC_UART_GET_UART(READING_UART), UART_BAUD_RATE, MXC_UART_APB_CLK);
   read_req.uart = MXC_UART_GET_UART(READING_UART);
   read_req.rxData = received_data;
   read_req.rxLen = DATA_SIZE;
   read_req.txLen = 0;
   read_req.callback = NULL;
   NVIC_ClearPendingIRQ(MXC_UART_GET_IRQ(READING_UART));
   NVIC_DisableIRQ(MXC_UART_GET_IRQ(READING_UART));
   NVIC_SetVector(MXC_UART_GET_IRQ(READING_UART), (uint32_t)UART2_IRQHandler);
   NVIC_EnableIRQ(MXC_UART_GET_IRQ(READING_UART));
   MXC_UART_ClearRXFIFO(uart);
   MXC_UART_TransactionAsync(&read_req);
}
void gpio_setup(void) {
   mxc_gpio_cfg_t gpio0_cfg;
   mxc_gpio_cfg_t gpio1_cfg;
   gpio0_cfg.port = PULSE_PORT;
   gpio0_cfg.mask =  PULSE_PIN;
   gpio0_cfg.pad = MXC_GPIO_PAD_NONE;
   gpio0_cfg.func = MXC_GPIO_FUNC_OUT;
   gpio0_cfg.vssel =MXC_GPIO_VSSEL_VDDIO; //set to 1.8v
   gpio1_cfg.port = UART_PORT;
   gpio1_cfg.mask = UART_TX_PIN | UART_RX_PIN;
   gpio1_cfg.pad = MXC_GPIO_PAD_NONE;
   gpio1_cfg.func = MXC_GPIO_FUNC_ALT1;
   gpio1_cfg.vssel =MXC_GPIO_VSSEL_VDDIO; //set to 1.8v
   MXC_GPIO_Config(&gpio0_cfg);
   MXC_GPIO_Config(&gpio1_cfg);
}
void start_pulse(void) {
   while (data_index < DATA_SIZE) {
       MXC_GPIO_OutSet(PULSE_PORT, PULSE_PIN);
       MXC_Delay(MXC_DELAY_MSEC(4)); // 1 / (2 * 200 Hz) = 2.5 ms, 1/(2*150hz)= 3.3 mS, 1/(2*125hz)=4ms
       MXC_GPIO_OutClr(PULSE_PORT, PULSE_PIN);
       MXC_Delay(MXC_DELAY_MSEC(4));// 1 / (2 * 200 Hz) = 2.5 ms, 1/(2*150hz)= 3.3 mS
   }
}





// Classification layer:
static int32_t ml_data[CNN_NUM_OUTPUTS];
static q15_t ml_softmax[CNN_NUM_OUTPUTS];

void softmax_layer(void)
{
  cnn_unload((uint32_t *) ml_data);
  softmax_q17p14_q15((const q31_t *) ml_data, CNN_NUM_OUTPUTS, ml_softmax);
}

int main(void)
{
  int i;
  int digs, tens;

  MXC_ICC_Enable(MXC_ICC0); // Enable cache

  // Switch to 100 MHz clock
  MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
  SystemCoreClockUpdate();

  printf("Waiting...\n");

  // DO NOT DELETE THIS LINE:
  MXC_Delay(SEC(2)); // Let debugger interrupt if needed

  // Enable peripheral, enable CNN interrupt, turn on CNN clock
  // CNN clock: APB (50 MHz) div 1



  SystemInit();
  gpio_setup();
  uart_setup();
  uint8_t START = 0x01;
  uint8_t STOP = 0x02;
  mxc_uart_regs_t* uart = MXC_UART_GET_UART(READING_UART);
  MXC_UART_WriteCharacterRaw(MXC_UART_GET_UART(READING_UART), START);
  printf("Start state\n");

  start_pulse();  // Start generating 200 Hz pulse

  while (data_index < DATA_SIZE);// Wait for data reception to complete

  MXC_UART_WriteCharacterRaw(uart, STOP);  // Stop the measurement
  printf("Stop state\n");

  for (int i = 0; i < DATA_SIZE; i++) {
  	        input_0[i] = (uint32_t)received_data[i];
  	    }
  //MXC_Delay(1000);
  cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK, MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);
  printf("\n*** CNN Inference Test ecgarrhy_v1 ***\n");
  printf("CNN init\n");
  cnn_init(); // Bring state machine into consistent state
  printf("CNN load weight\n");
  cnn_load_weights(); // Load kernels
  printf("CNN load bias\n");
  cnn_load_bias(); // Not used in this network
  printf("CNN configue\n");
  cnn_configure(); // Configure state machine
  printf("load input\n");
  load_input(); // Load data input
  printf("cnn start\n");
  cnn_start(); // Start CNN processing


  while (cnn_time == 0)
    MXC_LP_EnterSleepMode(); // Wait for CNN

  //if (check_output() != CNN_OK) fail();
  softmax_layer();

  printf("\n*** PASS ***\n\n");

#ifdef CNN_INFERENCE_TIMER
  printf("Approximate inference time: %u us\n\n", cnn_time);
#endif

  cnn_disable(); // Shut down CNN clock, disable peripheral

  printf("Classification results:\n");
  for (i = 0; i < CNN_NUM_OUTPUTS; i++) {
    digs = (1000 * ml_softmax[i] + 0x4000) >> 15;
    tens = digs % 10;
    digs = digs / 10;
    if(i==0)
    {
    	printf("[%7d] -> Class Sinus_rhytmus %d: %d.%d%%\n", ml_data[i], i, digs, tens);
    }
    else
    {
    	printf("[%7d] -> Class Atrial_fibrillation  %d: %d.%d%%\n", ml_data[i], i, digs, tens);
    }
    //printf("[%7d] -> Class %d: %d.%d%%\n", ml_data[i], i, digs, tens);
  }
  /*for (int i = 0; i < DATA_SIZE; i++)
     	{
             printf("%d\n",received_data[i] & 0xFF);
     		//putchar(received_data[i]);
             MXC_Delay(100);
         }
  return 0;*/
}

/*
  SUMMARY OF OPS
  Hardware: 18,546,568 ops (18,269,384 macc; 277,184 comp; 0 add; 0 mul; 0 bitwise)
    Layer 0: 159,520 ops (127,616 macc; 31,904 comp; 0 add; 0 mul; 0 bitwise)
    Layer 1: 8,206,464 ops (8,142,848 macc; 63,616 comp; 0 add; 0 mul; 0 bitwise)
    Layer 2: 8,154,752 ops (8,028,160 macc; 126,592 comp; 0 add; 0 mul; 0 bitwise)
    Layer 3: 1,917,504 ops (1,867,776 macc; 49,728 comp; 0 add; 0 mul; 0 bitwise)
    Layer 4: 72,928 ops (67,584 macc; 5,344 comp; 0 add; 0 mul; 0 bitwise)
    Layer 5: 35,200 ops (35,200 macc; 0 comp; 0 add; 0 mul; 0 bitwise)
    Layer 6: 200 ops (200 macc; 0 comp; 0 add; 0 mul; 0 bitwise)

  RESOURCE USAGE
  Weight memory: 115,400 bytes out of 442,368 bytes total (26.1%)
  Bias memory:   0 bytes out of 2,048 bytes total (0.0%)
*/
